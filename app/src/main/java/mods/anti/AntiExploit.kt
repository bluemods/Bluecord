package mods.anti

import com.discord.models.message.Message
import com.discord.widgets.chat.list.adapter.WidgetChatListAdapterEventsHandler
import com.discord.widgets.user.usersheet.WidgetUserSheet
import mods.dialog.DialogItemBuilder
import mods.dialog.Dialogs
import mods.utils.ClipboardUtil
import mods.utils.LogUtils

/**
 * Fixing exploits.
 */
@Suppress("UNUSED")
object AntiExploit {

    /**
     * Fixes a legacy crash shown to me from a hacker
     */
    @JvmStatic
    fun isUnsafeText(text: CharSequence?): Boolean {
        if (text.isNullOrEmpty()) return false
        return text.toString().contains("\u0000")
    }

    /**
     * A logic flaw exists in Discord where normally a user becomes impossible to ban.
     *
     * See github.com/bluemods/bluecord/app/docs/webhook_exploit.json for the payload,
     * extracted from when someone spammed it to troll my Discord server.
     *
     * How does it work?
     *
     * It works by making the `author` a placeholder stand-in account,
     * then the UI of the app shows that account when you click on the profile.
     *
     * Banning that profile then does nothing, because it is not the true author of the post.
     *
     * Disabling webhooks does nothing to stop them.
     *
     * The key is: the real profile information is in the `interaction_metadata` field.
     *
     * Banning that, as the true author of the post, stops the spam in its tracks.
     *
     * To fix this, if we detect potential spoofs, upon clicking the profile
     * we give the user a dialog, allowing them to select the spoofed author or the real author.
     *
     * @return true if intercepted
     */
    @JvmStatic
    fun onMessageAuthorAvatarClickedInterceptingWebhookExploit(
        ev: WidgetChatListAdapterEventsHandler,
        message: Message,
        guildId: Long
    ): Boolean {
        val meta = message.interactionMetadata
        LogUtils.log("Metadata", meta)

        if (meta == null) return false // not a webhook exploit
        if (!message.isWebhook) return false // not a webhook exploit
        if (message.author.e() != true) return false // not a bot

        val fakeUserId = message.author.id
        val fakeUserUsername = message.author.username

        val realUserId = meta.user.id
        val realUserUsername = meta.user.username

        if (fakeUserId == realUserId) return false // not a spoof

        fun showSheet(userId: Long) {
            WidgetUserSheet.Companion.`show$default`(
                WidgetUserSheet.Companion,
                userId,
                java.lang.Long.valueOf(message.channelId),
                ev.host.parentFragmentManager,
                java.lang.Long.valueOf(guildId),
                null,
                null,
                null,
                112,
                null
            )
        }

        Dialogs.newBuilder(ev.host.requireContext())
            .setTitle("Select a user...")
            .setItems(DialogItemBuilder().apply {
                addAction("@${fakeUserUsername} (Spoofed bot account)") { showSheet(fakeUserId) }
                addAction("@${realUserUsername} (Real account)") { showSheet(realUserId) }
            })
            .setNeutralButton("Copy IDs") {
                ClipboardUtil.copy(data = buildString {
                    append(
                        "Bot account:\nUsername: $fakeUserUsername\nID: $fakeUserId\n\n" +
                        "User account: \nUsername: $realUserUsername\n ID: $realUserId"
                    )
                }, toastMessage = run {
                    "Copied"
                })
            }
            .setPositiveButton("Exit")
            .showSafely()

        return true
    }
}